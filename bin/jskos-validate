#!/usr/bin/env node

const fs = require("fs")
const program = require("../lib/cli")
const { guessObjectType } = require("jskos-tools")
const jskosValidate = require("jskos-validate")
const readline = require("readline")

function message(msg, color=0) {
  console.log(process.stdout.isTTY && color ?`\x1b[${color}m${msg}\x1b[0m` : msg)
}

function error(msg) {
  console.error(process.stderr.isTTY ? `\x1b[31m${msg}\x1b[0m` : msg)
}

program
  .usage("[options] [type] files...")
  .option("-v, --verbose", "show error messages")
  .option("-u, --unknown", "allow unknown fields")
  .example("-u concepts concepts.ndjson")
  .example("-v mappings mappings.ndjson")
  .example("--list-types")
  .action( () => {
    const env = program
    args = (env.args || []).filter(a => typeof a === "string")

    if (!args.length) {
      program.help()
    }
    
    let type = (guessObjectType(args[0], true) || "").toLowerCase()
    if (type in jskosValidate) {
      type = args.shift().replace(/s$/,"")
    } else if (!fs.existsSync(args[0])) {
      error(`unknown object type: ${args[0]}`)
      process.exit(1)
    } else {
      type = "item"
    }

    const unknownFields = !!env.unknown
    const validate = (type, data, counter) => {
      const validator = jskosValidate[type]
      const result = validator(data, { unknownFields })
      if (!result) {
        if (env.verbose) {
          error(`# invalid ${type} ${counter}:`)
          validator.errorMessages.map(msg => console.error(`# ${type} ${msg}`))
        } else {
          error(`# invalid ${type} ${counter}`)
        }
      }
      return result
    }

    let fail = 0
    if (args.length && args[0] !== "-") { // validate files
      args.forEach( (file, i) => {
        let json = fs.readFileSync(file).toString()
        let data = file.match(/\.ndjson$/)
          ? json.split(/\n/).filter(Boolean).map(JSON.parse) 
          : JSON.parse(json)
        let objects = Array.isArray(data) ? data : [data]
        let counter = 1
        let ok = objects.every(obj => validate(type, obj, counter++))

        if (ok) {
          message(`ok     ${i+1} - ${file}`, 32)
        } else {
          message(`not ok ${i+1} - ${file}`, 31)
          if (fail < 99) fail++
        }
      })
      process.exit(fail)
    } else { // validate NDJSON from STDIN
      let counter = 1
      const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
        terminal: false
      })
      rl.on("line", data => {
        if (!validate(type, JSON.parse(data), counter++)) {
          if (fail < 99) fail++
        }
      })
      rl.on("close", () => process.exit(fail) )
    }
  })

program.parse(process.argv)
